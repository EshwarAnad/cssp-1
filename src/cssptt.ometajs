ometa CSSBSParser {

    // Tokens

    IDENT           = m_ident:x                                                     -> [#ident, x],
    ATKEYWORD       = '@' m_ident:x                                                 -> [#atkeyword, x],
    STRING          = m_string:x                                                    -> [#string, x],
    HASH            = '#' m_name:x                                                  -> [#hash, x],
    NUMBER          = m_num:x                                                       -> [#num, x],
    PERCENTAGE      = m_num:x '%'                                                   -> [#percentage, x],
    DIMENSION       = m_num:x m_ident:y                                             -> [#dimension, x, y],
    CDO             = seq('<!--')                                                   -> [#cdo],
    CDC             = seq('-->')                                                    -> [#cdc],
    S               = ((:x m_w(x)) -> x)+:xx                                        -> [#white, xx.join('')],
    ATTR_SELECTOR   = (seq('=') | seq('~=') | seq('^=') | seq('$=') | seq('*=')):x  -> [#attrselector, x],
    DELIM           = ',' S*                                                        -> [#delim, ','],
    COMMENT         = (anything*:x -> x.join('')):y m_comment(y)                    -> [#comment, y],

    // Macros

    m_ident         = ('-' | '*')*:x (:y m_nmstart(y)) ((:z m_nmchar(z)) -> z)*:zz  -> (x.join('') + y + zz.join('')),
    m_name          = ((:x m_nmchar(x)) -> x)+:xx                                   -> xx.join(''),
    m_num           = digit+:x '.' digit+:y                                         -> (x.join('') + '.' + y.join(''))
                    | '.' digit+:x                                                  -> ('.' + x.join(''))
                    | digit+:x                                                      -> x.join(''),
    m_string        = '"' (m_string_nl1 | ~'"' char)*:s '"'                         -> ('"' + s.join('') + '"')
                    | '\'' (m_string_nl2 | ~'\'' char)*:s '\''                      -> ('\'' + s.join('') + '\''),
    m_string_nl1    = ('\n' | '\r' | '\f' | seq('\\"')):x                           -> x,
    m_string_nl2    = ('\n' | '\r' | '\f' | seq('\\\'')):x                          -> x,

    m_nmstart :x    = ?CSSBSParser._m_nmstart(x),
    m_unicode :x    = ?CSSBSParser._m_unicode(x),
    m_escape :x     = ?CSSBSParser._m_escape(x),
    m_nmchar :x     = ?CSSBSParser._m_nmchar(x),
    m_nl :x         = ?CSSBSParser._m_nl(x),
    m_w :x          = ?CSSBSParser._m_w(x),
    m_comment :x    = ?CSSBSParser._m_comment(x)
}

ometa CSSParser <: CSSBSParser {
    stylesheet      = (CDO | CDC | S | statement)*:x                                                -> this.concat([#stylesheet], x),
    statement       = (ruleset | atrule),
    atrule_part     = (any | operator | S),
    atrule          = seq('@media') atrule_part*:ap '{' S* ruleset*:r S* '}'                        -> this.concat([#atrulem], ap, r) // media
                    | ATKEYWORD:ak atrule_part*:ap block:b                                          -> this.concat([#atruleb, ak], ap, [b]) // block
                    | ATKEYWORD:ak atrule_part*:ap ';' S*                                           -> this.concat([#atrules, ak], ap), // single
    block           = '{' S* declaration*:x '}'                                                     -> this.concat([#block], x),
    ruleset         = selector*:x block:y S*                                                        -> this.concat([#ruleset], x, [y]),
    combinator      = ('+' | '>' | '~'):x                                                           -> [#combinator, x],
    space_selector  = S:x any:y                                                                     -> [x, y],
    combi_selector  = S* combinator:c S* any:x                                                      -> [c, x],
    attrib          = '[' S*:s0 IDENT:x S*:s1 ATTR_SELECTOR:a S*:s2 (IDENT | STRING):y S*:s3 ']'    -> [this.concat([#attrib], s0, [x], s1, [a], s2, [y], s3)],
    class           = '.' IDENT:i                                                                   -> [#class, i],
    simple_selector = any:x (combi_selector | space_selector | attrib)*:y S*                        -> this.concatContent([#simpleselector, x], y),
    selector        = (simple_selector | DELIM)+:x                                                  -> this.concat([#selector], x),
    declaration     = property:x S* ':' S* value:y S* ';'*                                          -> [#declaration, x, y],
    property        = IDENT:x                                                                       -> [#property, x],
    prio            = '!' S* seq('important') S*                                                    -> [#important],
    unary_operator  = ('-' | '+'):x                                                                 -> [#unary, x],
    operator        = ('/' | ','):x                                                                 -> [#operator, x],
    uri             = seq('url') '(' STRING:x ')'                                                   -> [#uri, x]
                    | seq('url') '(' (:x ?(x !== ')') -> x)*:xx ')'                                 -> [#uri, [#raw, xx.join('')]],
    value           = (any | block | ATKEYWORD | operator | S)+:x                                   -> this.concat([#value], x),
    func            = IDENT:x '(' (any | S)*:y ')'                                                  -> this.concat([#function, x], y),
    any             = unary_operator*:x (class | STRING | PERCENTAGE | DIMENSION |
                        HASH | NUMBER | uri | func | IDENT | operator):y                            -> x.concat(y)
                    | '(' S* any*:x ')' S*                                                          -> this.concat([#braces, '(', ')'], x)
                    | '[' S* any*:x ']' S*                                                          -> this.concat([#braces, '[', ']'], x)
}

CSSParser.concatContent = function(x, y) {
    y.forEach(function(e) {
        x = x.concat(e);
    });

    return x;
};

CSSParser.concat = function() {
    var x = [];
    for (var i in arguments) {
        x = x.concat(arguments[i]);
    };

    return x;
};

ometa CSSTransformer {
    trans = [:t apply(t):x] -> x,

    ident           :x                  -> [#ident, x],
    atkeyword       :x                  -> [#atkeyword, x],
    string          :x                  -> [#string, x],
    hash            :x                  -> [#hash, x],
    num             :x                  -> [#num, x],
    percentage      :x                  -> [#percentage, x],
    dimension       :x :y               -> [#dimension, x, y],
    cdo                                 -> [#cdo],
    cdc                                 -> [#cdc],
    white           :x                  -> [#white, x],
    attrselector    :x                  -> [#attrselector, x],
    attrib          trans*:x            -> [#attrib].concat(x),
    class           trans:x             -> [#class, x],
    delim           :x                  -> [#delim, x],
    stylesheet      :x trans*:y         -> [#stylesheet].concat(y),
    atrulem         trans*:x            -> [#atrulem].concat(x),
    atruleb         trans*:x            -> [#atruleb].concat(x),
    atrules         trans*:x            -> [#atrules].concat(x),
    block           trans*:x            -> [#block].concat(x),
    ruleset         trans*:x            -> [#ruleset].concat(x),
    combinator      :x                  -> [#combinator, x],
    simpleselector  trans*:x            -> [#simpleselector].concat(x),
    selector        trans*:x            -> [#selector].concat(x),
    declaration     trans:p trans*:v    -> [#declaration, p].concat(v),
    property        trans:x             -> [#property, x],
    important                           -> [#important],
    unary           :x                  -> [#unary, x],
    operator        :x                  -> [#operator, x],
    braces          :x :y trans*:z      -> [#braces, x, y].concat(z),
    value           trans*:x            -> [#value].concat(x),
    comment         :x                  -> [#comment, x],
    uri             trans:x             -> [#uri, x],
    raw             :x                  -> [#raw, x],
    function        trans:x trans*:y    -> [#function, x].concat(y)
}

ometa CSSTranslator {
    trans = [:t apply(t):x] -> x,

    ident           :x                  -> x,
    atkeyword       :x                  -> ('@' + x),
    string          :x                  -> x,
    hash            :x                  -> ('#' + x),
    num             :x                  -> x,
    percentage      :x                  -> (x + '%'),
    dimension       :x :y               -> (x + y),
    cdo                                 -> '<!--',
    cdc                                 -> '-->',
    white           :x                  -> x,
    attrselector    :x                  -> x,
    attrib          trans*:x            -> ('[' + x.join('') + ']'),
    class           trans:x             -> ('.' + x),
    delim           :x                  -> x,
    stylesheet      :x trans*:y         -> y.join(''),
    atrulem         trans*:x            -> ('@media' + x.join('')),
    atruleb         trans*:x            -> x.join(''),
    atrules         trans*:x            -> (x.join('') + ';'),
    block           trans*:x            -> ('{' + x.join(';') + '}'),
    ruleset         trans*:x            -> x.join(''),
    combinator      :x                  -> x,
    simpleselector  trans*:x            -> x.join(''),
    selector        trans*:x            -> x.join(''),
    declaration     trans:p trans*:v    -> (p + ':' + v.join('')),
    property        trans:x             -> x,
    important                           -> '!important',
    unary           :x                  -> x,
    operator        :x                  -> x,
    braces          :x :y trans*:z      -> (x + z.join('') + y),
    value           trans*:x            -> x.join(''),
    comment         :x                  -> x,
    uri             trans:x             -> ('url(' + x + ')'),
    raw             :x                  -> x,
    function        trans:x trans*:y    -> (x + '(' + y.join('') + ')')
}
