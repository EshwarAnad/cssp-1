ometa CSSBSParser {

    // Tokens

    IDENT = m_ident:x -> [#ident, x],

    ATKEYWORD = '@' m_ident:x -> [#atkeyword, x],

    STRING = m_string:x -> [#string, x],

    HASH = '#' m_name:x -> [#hash, x],

    NUMBER = m_num:x -> [#num, x],

    PERCENTAGE = m_num:x '%' -> [#percentage, x],

    DIMENSION = m_num:x m_ident:y -> [#dimension, x, y],

    CDO = seq('<!--') -> [#cdo],

    CDC = seq('-->') -> [#cdc],

    S = (' ' | '\t' | '\r' | '\n' | '\f')+:x -> [#white, x.join()],

    ATTR_SELECTOR = (seq('=') | seq('~=') | seq('^=') | seq('$=') | seq('*=')):x -> [#attrselector, x],

//    FUNCTION = m_ident:x '(' -> x,

    DELIM = ',' S* -> [#delim, ','],

    // Macros

    m_ident = '-'*:x (:y m_nmstart(y)) ((:z m_nmchar(z)) -> z)*:zz -> (x.join('') + y + zz.join('')),

    m_name = ((:x m_nmchar(x)) -> x)+:xx -> xx.join(''),

    m_nmstart :x = ?CSSBSParser._m_nmstart(x),

    m_unicode :x = ?CSSBSParser._m_unicode(x),

    m_escape :x = ?CSSBSParser._m_escape(x),

    m_nmchar :x = ?CSSBSParser._m_nmchar(x),

    m_num = digit+:x '.' digit+:y -> (x.join('') + '.' + y.join(''))
          | '.' digit+:x -> ('.' + x.join(''))
          | digit+:x -> x.join(''),

    m_string = '"' (m_string_nl1 | ~'"' char)*:s '"' -> ('"' + s.join('') + '"')
             | '\'' (m_string_nl2 | ~'\'' char)*:s '\'' -> ('\'' + s.join('') + '\''),

    m_string_nl1 = ('\n' | '\r' | '\f' | seq('\\"')):x -> x,

    m_string_nl2 = ('\n' | '\r' | '\f' | seq('\\\'')):x -> x,

    m_nl :x = ?CSSBSParser._m_nl(x),

    m_w :x = ?CSSBSParser._m_w(x)
}

ometa CSSParser <: CSSBSParser {
    stylesheet = (CDO | CDC | S | statement)*:x -> [#stylesheet].concat(x),

    statement = (ruleset | atrule),

    atrule_part = (any | operator | S),

    atrule = seq('@media') S* atrule_part*:ap '{' S* ruleset*:r S* '}' -> [#atrulem].concat(ap).concat(r) // media
           | ATKEYWORD:ak S* atrule_part*:ap block:b -> [#atruleb, ak].concat(ap).concat(b) // block
           | ATKEYWORD:ak S* atrule_part*:ap ';' S*  -> [#atrules, ak].concat(ap), // single

    block = '{' S* (any | block | ATKEYWORD | ';' | S)*:x '}' S* -> [#block].concat(x),

    ruleset = selector*:x '{' S* declaration*:y '}' S* -> [#ruleset].concat(x).concat(y),

    combinator = ('+' | '>'):x -> [#combinator, x],

    space_selector = S* any:x -> [[#combinator, ' '], x],

    combi_selector = S* combinator:c S* any:x -> [c, x],

    simple_selector = any:x (combi_selector | space_selector)*:y S* -> this.concatElements([#simpleselector, x], y),

    selector = (simple_selector | DELIM)+:x -> [#selector].concat(x),

    declaration = property:x S* ':' S* value:y S* ';'* -> [#declaration, x, y],

    property = IDENT:x -> [#property, x],

    prio = '!' S* seq('important') S* -> [#important],

    unary_operator = ('-' | '+'):x -> [#unary, x],

    operator = ('/' | ','):x S* -> [#operator, x],

    value = (any | block | ATKEYWORD | operator | S)+:x -> [#value].concat(x),

    func = IDENT:x '(' S* any*:y ')' -> [#function, x, y],

    any = unary_operator*:x (STRING | PERCENTAGE | DIMENSION | HASH | NUMBER | ATTR_SELECTOR | func | IDENT):y -> x.concat(y)
        | '(' S* any*:x ')' S* -> ['(', x, ')']
        | '[' S* any*:x ']' S* -> ['[', x, ']']
}

CSSParser.concatElements = function(x, y) {
    y.forEach(function(e) {
        x = x.concat(e);
    });

    return x;
};

ometa CSSTranslator {
    trans = [:t apply(t):ans] -> ans,

    ident :x -> x,
    atkeyword :x -> ('@' + x),
    string :x -> x,
    hash :x -> ('#' + x),
    num :x -> x,
    percentage :x -> (x + '%'),
    dimension :x -> (x + y),
    cdo -> '<!--',
    cdc -> '-->',
    white :x -> x,
    attrselector :x -> x,
    delim :x -> x,
//    stylesheet
//    atruleb
    atrules trans:x -> x,
//    block
//    ruleset
    combinator :x -> x,
//    simpleselector
//    selector
//    declaration
    property :x -> x,
    important -> '!important',
    unary :x -> x,
    operator :x -> x
//    value
//    function
}
